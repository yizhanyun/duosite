import deepmerge from 'deepmerge'
import fastifyStatic from 'fastify-static'
import path from 'path'

import {
  genericGetRoute,
  buildFileRouter,
  buildApiRouter,
} from './getHandler.mjs'

import {
  buildFileRoutingTable,
  buildApiRoutingTable,
  buildApiRouteUrlVariableTable,

  buildFileRouteUrlVariableTable,
} from '../utils.mjs'

const siteRootName = 'sites'


const isProduction = process.env.NODE_ENV === 'production'

//  Plugin to handle each subsite's request

// opts: { prefix, _duosite: { siteRoot }}

const buildSubsitePlugin = async (buildSite, target) => {
  const subsite = async function (fastify, opts, done) {
    const { _duosite, prefix: site } = opts

    const { global } = _duosite

    const { root, settings: globalSettings, i18nMessages, lang } = global

    const siteRoot = path.join(
      root,
      siteRootName,
      site,
      isProduction ? '.production' : ''
    )
    // load subsite settings
    let sharedSetting, byEnironmentSetting
    try {
      sharedSetting = (await import(`${siteRoot}/settings.mjs`)).default
     byEnironmentSetting =
      process.env.NODE_ENV === 'production'
        ? (await import(`./${siteRoot}/settings.production.mjs`)).default || {}
      : (await import(`./${siteRoot}/settings.development.mjs`)).default || {}
    } catch (e) {
      console.log(e)
    }

    const settings = deepmerge(sharedSetting || {}, byEnironmentSetting || {})



    const {
      staticRoot = 'static', // Root for statics that are serverved as is.
      staticCompiledRoot = 'bundle', // Root for statics that are generated by bundlers
      viewEngine = {},
    } = settings

    // Build global services

    let buildSiteServices
    
    try {
      buildSiteServices  =  (await import(`${siteRoot}/src/siteServices`)).default
    } catch (e) {
    }

    const siteServices = buildSiteServices
      ? buildSiteServices(globalSettings, settings, root)
      : {}

    // build site  enhancer

    let enhance
    try {
      ehance    = (await import(`${siteRoot}/src/enhancer.mjs`)).default
    } catch (e) {

    }
    // build site engine


    const { name, ext, options = {} } = viewEngine

    site === 'test-1' && console.log('%%%%%%%%%%%%%%%%%%%%%% viewEngine ', viewEngine, site )      

    let engine

    if (name && ext) {
      let buildEngine

      try {
        buildEngine = (await import(`${siteRoot}/plugins/engines.mjs`)).default
      } catch (e) {
          console.log(e)
      }

      if (buildEngine) {
        // use local provided engines

        engine = await buildEngine(siteRoot, name, ext, options, lang, i18nMessages)
      } else {
        // use global engines
        let buildEngine
        try {
          buildEngine   = (await import('./engines.mjs')).default
        } catch (e) {
          console.log(e)
        }
        if (buildEngine) {
          console.log('%%%%%%%%%%%%%%%%%%%%%% buildEngine ', buildEngine )      
          engine = await buildEngine(siteRoot, name, ext, options, lang, i18nMessages)
        }
      }
    }

    // Add static handlers

    fastify.register(fastifyStatic, {
      root: path.join(siteRoot, 'public', staticRoot),
      prefix: `/${staticRoot}`,
    })

    if (staticCompiledRoot !== staticRoot) {
      fastify.register(fastifyStatic, {
        root: path.join(siteRoot, 'public', staticCompiledRoot),
        prefix: `/${staticCompiledRoot}`,
        decorateReply: false, // the reply decorator has been added by the first plugin registration
      })
    }

    fastify.decorateRequest('_duosite', null)

    // enhance request with _duosite

    const duositeConfig = {
      ..._duosite,
      site: {
        root: siteRoot,
        settings,
        engine,
        services: siteServices,
      },
    }
    fastify.addHook('preHandler', (request, reply, done) => {
      request._duosite = duositeConfig
      done()
    })

    fastify.route(genericGetRoute)

    try {
      const fileRoutingTable = buildFileRoutingTable(
        path.join(siteRoot, 'pages'),
        ext
      )

      const fileRoutingUrlVariableTable = buildFileRouteUrlVariableTable(
        fileRoutingTable
      )

      fileRoutingUrlVariableTable.forEach(tables => {
        tables.forEach(table => {
          const router = buildFileRouter(table)
          fastify.route(router)
        })
      })

      const apiRoutingTable = buildApiRoutingTable(
        path.join(siteRoot, 'api'),
        '.js'
      )
      const apiRoutingUrlVariableTable = buildApiRouteUrlVariableTable(
        apiRoutingTable
      )

      apiRoutingUrlVariableTable.forEach(tables => {
        tables.forEach(table => {
          const router = buildApiRouter(table, siteRoot)
          fastify.route(router)
        })
      })
    } catch (e) {
      console.log(e)
    }

    enhance && enhance(fastify, duositeConfig)

    if (buildSite && (target === '*' || target === site)) {
      let defaultBuildSite
      try {
        defaultBuildSite = (await import('./src/buildSite.mjs')).default
      } catch (e) {
        console.log(e)
      }

      let customBuildSite

      const segs = siteRoot.split('/')
      segs.pop()

      const devSiteRoot = segs.join('/')
      try {
        customBuildSite = (await import(path.join(devSiteRoot, 'src', 'buildSite.mjs'))).default
      } catch (e) {
        console.log(e)
      }

      const prebuild =
        (customBuildSite && customBuildSite.prebuild) ||
        (defaultBuildSite && defaultBuildSite.prebuild)

      prebuild && await prebuild(devSiteRoot, duositeConfig)

      const _build =
        (customBuildSite && customBuildSite.build) ||
        (defaultBuildSite && defaultBuildSite.build)

      _build && await _build(devSiteRoot, duositeConfig)

      const postbuild =
        (customBuildSite && customBuildSite.postbuild) ||
        (defaultBuildSite && defaultBuildSite.postbuild)

      postbuild && await postbuild(devSiteRoot, duositeConfig)
    }

    done()
  }

  return subsite
}

export default buildSubsitePlugin
